---
title: 'How to reproduce EmuNoc'
date: 2025-02-18
permalink: /posts/2025/02/emunoc/
tags:
  - FPGA
  - Petalinux
  - Network on Chip
  - HW/SW Co-design
---

`EmuNoC` is a hybrid emulation framework for prototyping Networks-on-Chip (NoCs) on FPGAs.

# Summary of the publication

[`EmuNoC`: Hybrid Emulation for Fast and Flexible Network-on-Chip Prototyping on FPGAs](https://arxiv.org/abs/2206.11613)

The paper presents **EmuNoC**, a hybrid **emulation framework** for **prototyping Networks-on-Chip (NoCs) on FPGAs**. NoCs are critical for communication in multi-core CPUs and edge AI accelerators. EmuNoC enhances speed and flexibility compared to existing methods by using a hybrid approach where the NoC is emulated on the FPGA while traffic patterns are generated and controlled via software.

Key contributions include:
1. **Clock Synchronization Method**: A hardware-based approach to synchronize the NoC with the virtual platform.
2. **Software-only Packet Generation**: Retains flexibility while achieving 36.3× to 79.3× speedup over state-of-the-art frameworks.
3. **High Area Efficiency**: Models up to 169 routers on a single FPGA, outperforming previous methods.

EmuNoC demonstrates its effectiveness in two case studies: 
- Multi-core processors using synthetic traffic and realistic benchmarks (e.g., `Netrace`).
- Neuromorphic edge-AI accelerators with traffic patterns specific to CNNs.

# tools used

> simulation

- simulators `Booksim 2.0`, `Noxim` [10], and `Ratatoskr` [26] using dimension-ordered routing, 5-flit packets.
- We measure the median of 10 simulations on a `WSL Ubuntu 20.04.2 LTS` using one Intel i7-5700HQ core at 2.7 GHz.

> HW/SW Co-design

- PetaLinux
- `Vivado 2018.2` for a `Zynq UltraScale+ MPSoC ZCU102`. The global clock (Fig. 3) is set to `80MHz` and the FIFOs in the NoC and the transactor use the Xilinx’s `FIFO IP` to support larger setups. 

# System architecture

So, `EmuNoc` is a framework to emulate the performance of Noc on FPGAs (FPGA should be ZYNQ architecture). Firstly, you need to build the network on chip which could be emulated, then you need to design the emulator to emulate the performance of the Noc. So we need to finish two parts, the Noc, and the EmuNoc.

`EmuNoc` is a little different because it not only uses the PL but also utilizes the PS to make the emulator more flexible. It's kind of hybrid emulation to get higher performance.

## Required Prior Knowledge for Reproduction

1. **Basics of Networks-on-Chip (NoC)**
   - Understand NoC architectures, communication protocols, and performance metrics (e.g., latency, throughput).

2. **FPGA Design**
   - Knowledge of FPGA architecture and toolchains (e.g., Vivado or similar).
   - Experience with Hardware Description Languages (e.g., Verilog or VHDL).

3. **Hybrid Emulation and Co-Simulation**
   - Familiarity with hybrid approaches that integrate hardware emulation with software simulation.
   - Understanding of AXI4-stream protocol and DMA communication for data transfer.

4. **Software Development for Embedded Systems**
   - Experience with PetaLinux and `userspace` I/O for FPGA-based systems.
   - Compiler optimization techniques for embedded software.

5. **Performance Evaluation Techniques**
   - Methods for benchmarking NoC designs using synthetic traffic and realistic workloads.
   - Knowledge of simulation and emulation frameworks like `Booksim`, `Noxim`, or `Ratatoskr`.

6. **Tools and Libraries**
   - Vivado for FPGA synthesis and implementation.
   - GitHub for accessing the EmuNoC open-source framework.

By mastering these topics, you can successfully reproduce the EmuNoC framework and adapt it for your use cases.

# easy guide to reproduce step by step

## generate the Noc

first, you should have a Noc. The Noc can be generated by the scripts in the [`ratatoskr-router`](https://github.com/ratatoskr-project/ratatoskr-router/tree/main/3d-router). There are a lot of parameters like `network size` and `virtural buffer number`. you should first determine these parameters to generate the Noc you want to emulate in the `noc_heter_gen.py` file. Here I generated a 5 × 5 mesh NoC (2 VCs and 8-flit buffer).

## change the settings of EmuNoc

Then you should change the parameters in the `EmuNoc` to align with the size of the NOC. The parameters are defined in the `NOC_3D_PACKAGE.vhd`. 

In the step of generating the NOC you want to emulate has generated the `NOC_3D_PACKAGE.vhd`. So just change parameters in the `noc_heter_gen.py` file. Until this step, you have built the `EmuNoc` for the PL part, which means the `EmuNoc` module composed of input ports and output ports.

Clone the EmuNoC repository from GitHub: [EmuNoC GitHub Repository](https://github.com/ICE-RWTH/EmuNoC).

## simulate the EmuNoc

then simulate the `EmuNoc` using GHDL and view the results.

## create a Vivado project consisting of Noc and EmuNoc

Then create a block design which consists of PetaLinux system in the PS and `EmuNoc` in the PL. then you export the hardware to the `.xsa` file which will be used in the next step to build the PetaLinux.

## build the PetaLinux

then you should build the PetaLinux in a Linux host machine like Ubuntu, following the steps like `petalinux-create`, `petalinux-config`, and `petalinux-build` finally generate the BOOT.bin file which can be downloaded in ZYNQ by SD card.

## run the executable file in PetaLinux to test the performance

then you should run the make file in the `EmuNoc-SW` to generate the executable file and transfer the file to PetaLinux by `scp` (secure copy). finally you could run the executable file in the serial terminal.

# details

## generate the Noc using `ratatoskr-router`

### parameters explaination

`ratatoskr-router` catalog structure: 

```bash
tree -d -L 1
.
├── noc_heter
├── noc_heter_high_throughput
├── noc_heter_high_throughput_with_pe
├── noc_heter_with_pe
└── traffic_generator_receiver
```

It contains four kinds of scripts to generate four kinds of NOC automatically. `noc_heter` only generates NOC, while `noc_heter_with_pe` generates NOC with PE.

For example, in `noc_heter`, the changeable parameters of `noc_heter_gen.py` contain:

- `noc_x,noc_y,noc_z`: the dimension of the generated NOC
- the parameters in Routing Algorithm should align with the parameters in EmuNoc. The number of `PE_INJECT` and `PE_EJECT` depends on `max_x_dim,max_y_dim,max_z_dim`. The size of `NUM_IO` depends on `max_x_dim,max_y_dim,max_z_dim` and `max_vc_num`.

```py
# 	Network size
noc_x=4
noc_y=4
noc_z=3
# 	Virtual Channel Number
vc_num=2
vc_xy=[4, 4, 4]    # Horizontal Ports VC numbers (array size = noc_z)
depth_xy=[4, 4, 4] # Horizontal Ports buffer depth (array size = noc_z)
vc_z =[4, 4]       # Up and Down ports VC numbers (array size = noc_z-1)
depth_z=[8, 8]     # Up and Down ports buffer depth (array size = noc_z-1)
# 	Routing Algorithm (character " is known as \")
flit_size= 32
max_vc_num=4
max_vc_num_out=4
max_x_dim=4
max_y_dim=4
max_z_dim=4
max_packet_len=31
max_port_num=7
rst_lvl=0
max_buffer_depth=8
cf=4
```

### generate NOC when z_dim = 1

follow the instructions in README

`fix 1: full_noc`：
```
vc_depth_out_array           => ((5, 5, 5, 5, 5), (5, 5, 5, 5, 5), (5, 5, 5, 5, 5), (5, 5, 5, 5, 5)),
```
to
```
vc_depth_out_array           => ((others => max_packet_len),(5, 5, 5, 5, 5), (5, 5, 5, 5, 5), (5, 5, 5, 5, 5), (5, 5, 5, 5, 5)),
```

`fix 2: noc_3d_package`

1. function bit_width

```
  function bit_width(x : positive) return positive is
  begin
    assert (x > 1) report "Encoding for less than two values is not possible"
      severity failure;
    return positive(ceil(log2(real(x))));
  end function;
```
to
```
  function bit_width(x : Positive) return Positive is
  begin
    if (x > 1) then
      return Positive(ceil(log2(real(x))));
    elsif x = 1 then
      return 1;
    else
      return 0;
    end if;
  end function;
```

2. If max_z_dim == 1
```
positive(ceil(log2(real(max_z_dim))))-1
```
to
```
  0
```

`fix 3: switch_allocator.vhd`

1. `rr_arbiter at vc allocation`

```
    ack   => switch_ack(i),
```
to
```
    ack   => '1',
```

2. one_hot2int --> count_trail_zero

```
  winner := lr + one_hot2int(channel_grant(ur downto lr));
```
  to
```
  winner := lr + count_trail_zero(channel_grant(ur downto lr)) mod vc_num_out_vec(i);
```

And add the function below. In VHDL, the function block should add before architecture `begin` and after `architecture rtl of` definition.

```
  function count_trail_zero(var : Std_logic_vector) return Integer is
    variable tmp                  : Std_logic_vector(var'length - 1 downto 0) := var;
  begin
    for i in 0 to tmp'length - 1 loop
      if tmp(i) = '1' then
        return i;
      end if;
    end loop;
    return tmp'length;
  end function;
```

## simulate the EmuNoc

- env: ubuntu 24.04, CPU Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz

- copy the generated NOC to the `EmuNOC-HW/src` folder. 注意这里是已经fix过之后的

- Install latest GHDL

```bash
make install
```

上面的指令实际上执行的是：

```bash
	git clone https://github.com/ghdl/ghdl.git
	cd ghdl
	sudo apt install gnat
	./configure --prefix=/usr/local
	make
	make install
	cd ..
```

Run testbench

```bash
make TEST_NAME=<testbench name>

make TEST_NAME=m_axis_ni_tb
make TEST_NAME=s_axis_ni_tb
make TEST_NAME=top_tb
```

报错：

```bash
./testbench/utils/traffic_gen.vhd:67:14:error: cannot open file: testdata/m_axis_ni_tb/in/inj_time.txt
        file inj_time       : text open read_mode is inj_time_text;
             ^
./testbench/utils/traffic_rec.vhd:39:14:error: cannot open file: testdata/m_axis_ni_tb/out/rec_time_text.txt
        file rec_time : text open write_mode is rec_time_text;
             ^
make: *** [Makefile:32: run] Error 1
```

需要先 generate test data：

```bash
cd EmuNoc-HW/testdata/m_axis_ni_tb
vim generate_test_data.py
```

`generate_test_data.py`:

```bash
# NoC configuration
max_x_dim = 5  # check noc pkg
max_y_dim = 5  # check noc pkg
max_z_dim = 1  # check noc pkg

flit_size = 32  # const
flit_pkt_width = 5  # check noc pkg
flit_addr_x_width = bit_width(max_x_dim)
flit_addr_y_width = bit_width(max_y_dim)
flit_addr_z_width = bit_width(max_z_dim)
flit_id_width = 8
flit_pad_width = flit_size - flit_id_width - flit_pkt_width \
    - 2 * (flit_addr_x_width + flit_addr_y_width + flit_addr_z_width)

# Router configuration
port_num = 7  # check noc pkg
```

```bash
python generate_test_data.py
```

还有报错：

```bash
./testbench/utils/traffic_gen.vhd:70:14:error: cannot open file: testdata/m_axis_ni_tb/out/inj_time.txt
        file inj_time_2_noc : text open write_mode is inj_time_2_noc_text;
             ^
./testbench/utils/traffic_rec.vhd:39:14:error: cannot open file: testdata/m_axis_ni_tb/out/rec_time_text.txt
        file rec_time : text open write_mode is rec_time_text;
             ^
make: *** [Makefile:32: run] Error 1
```

```bash
cd testdata/m_axis_ni_tb
mkdir out
cd out
touch inj_time.txt
touch rec_time_text.txt
```

```bash
sudo apt-get install gtkwave
```

## EmuNoc software configuration

### README

The statement **"Uncomment in the makefile for the cross compile that you needs. This depends on which Zynq processor that you are using."** refers to configuring the **cross-compilation** toolchain in the `Makefile` to target a specific Zynq processor architecture.

In the context of this **EmuNoC** software, **cross-compilation** means building the software on a host machine (typically a PC) for a different target architecture (in this case, a Zynq FPGA platform).

#### **What is Cross-Compilation?**

- **Cross-compiling** involves compiling software on one platform (e.g., your laptop or desktop with x86 architecture) to run on another platform with a different architecture (e.g., ARM-based Zynq processors).
- **Xilinx SDK** provides the necessary tools (cross-compilers) to compile code for ARM-based Zynq processors.

#### **Why is Cross-Compilation Needed for EmuNoC?**

- **Zynq Processors** (such as the Zynq-7000 or ZCU102) are **ARM-based**, so you cannot directly compile the software on your host machine (which is likely x86-based).
- You need to cross-compile the software to **create executables or shared objects** that can **run on the Zynq processor**.

#### **What Does the `Makefile` Have to Do with It?**

The `Makefile` has sections that specify the compiler and compilation flags for different architectures. Specifically, the lines related to cross-compilation are currently commented out, but they can be **uncommented** to use the **correct cross-compiler** depending on the Zynq processor you are using.

#### **How to Set Up the Cross-Compiler in the Makefile?**

In the `Makefile`, the relevant lines for cross-compiling are:

```makefile
# CROSS_COMPILE := arm-linux-gnueabihf-
# CROSS_COMPILE := aarch64-linux-gnu-
```

- **`arm-linux-gnueabihf-`**: This is the prefix for the **32-bit ARM architecture** (e.g., for Zynq-7000 series).
- **`aarch64-linux-gnu-`**: This is the prefix for the **64-bit ARM architecture** (e.g., for ZCU102 or other newer Zynq UltraScale+ series).

#### **What You Need to Do:**

1, **Uncomment the Appropriate Line**: 
- If you're targeting a **32-bit Zynq processor** (like Zynq-7000), uncomment the line `CROSS_COMPILE := arm-linux-gnueabihf-`.
- If you're targeting a **64-bit ZCU102 or similar ARM processor**, uncomment the line `CROSS_COMPILE := aarch64-linux-gnu-`.

For example:
```makefile
CROSS_COMPILE := arm-linux-gnueabihf-
```

Or:
```makefile
CROSS_COMPILE := aarch64-linux-gnu-
```

2, **Install the Correct Cross-Compiler**: 
- You need to have the correct cross-compiler installed. This can typically be done through Xilinx's SDK or a toolchain provided by the processor manufacturer.
- For **32-bit ARM** (Zynq-7000), you might use `gcc-arm-linux-gnueabihf`.
- For **64-bit ARM** (ZCU102, UltraScale+), you might use `gcc-aarch64-linux-gnu`.

The Xilinx SDK should install the right toolchain, or you can install it manually depending on your setup.

3, **Proceed with Compilation**: Once you've uncommented the correct line for your processor, you can proceed with compiling the code using `make`. The toolchain specified will compile the software for the correct ARM architecture.

#### **Why Is This Step Important?**

Different Zynq processors (such as Zynq-7000 vs ZCU102) may have different instruction sets (32-bit vs 64-bit), so you need to ensure that the correct cross-compiler is used to generate machine code that will run on the specific ARM processor in your Zynq FPGA board.

### makefile

Let's break down the `Makefile` and understand its components:

#### **1. Variables and Paths**
```makefile
TARGET_EXEC := main

# directory
BUILD_DIR := ./build
SRC_DIR := ./src
INC_DIRS := ./src
```
- `TARGET_EXEC := main`: This sets the name of **the final executable to `main`. The `Makefile` will produce this file.**
- `BUILD_DIR := ./build`: This is the directory where object files (`.o`) will be stored during the build process.
- `SRC_DIR := ./src`: This is the directory where the source files (`.c`) are located.
- `INC_DIRS := ./src`: This is the directory containing the header files (`.h`) used for inclusion in the source code.

#### **2. Source Files and Object Files**
```makefile
SRCS := $(shell find $(SRC_DIR) -type f -iname '*.c')
OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)
INCS := $(foreach d, $(INC_DIRS), -I$d)
```
- `SRCS := $(shell find $(SRC_DIR) -type f -iname '*.c')`: This command uses the `find` shell utility to **locate all `.c` files** within the `SRC_DIR` (recursively). It stores the list of source files in the variable `SRCS`.
- `OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)`: This **converts the list of source files (`SRCS`) into corresponding object files (`.o`) in the `BUILD_DIR`.** For each `.c` file, it replaces the `.c` extension with `.o` and places it in the `build` directory.
- `INCS := $(foreach d, $(INC_DIRS), -I$d)`: This loop goes through the `INC_DIRS` list and adds `-I` flags for each directory. These flags tell the compiler **where to find header files during compilation**.

#### **3. Compiler Settings**
```makefile
CC := $(CROSS_COMPILE)gcc
C_FLAGS := -Wall -std=gnu11 -Ofast $(INCS)
C_LINK := -lm
```
- `CC := $(CROSS_COMPILE)gcc`: This sets the compiler to `gcc`. The `CROSS_COMPILE` part is commented out in the `Makefile`, but if uncommented, it would allow you to **cross-compile for a different architecture (e.g., ARM)**.
- `C_FLAGS := -Wall -std=gnu11 -Ofast $(INCS)`: This sets the compiler flags:
  - `-Wall`: Enable all warnings.
  - `-std=gnu11`: Use the GNU version of the C11 standard.
  - `-Ofast`: Optimize the code for speed (may sacrifice precision or standard compliance).
  - `$(INCS)`: **Add the necessary include directories** (`-I ./src` in this case).
- `C_LINK := -lm`: This **sets the linker flag to link the math library (`libm`)**, which is typically needed for mathematical functions like `sqrt()`.

#### **4. Targets**

```
all: $(TARGET_EXEC)
```
- `all: $(TARGET_EXEC)`: This is the default target. It depends on the `$(TARGET_EXEC)` target, meaning **the build process will attempt to create the final executable (`main` in this case)**.

```makefile
$(TARGET_EXEC): $(OBJS)
	$(CC) $(C_FLAGS) $(OBJS) -o $@ $(C_LINK)
```
- This rule builds the executable `$(TARGET_EXEC)` (which is `main`).
  - It depends on the object files (`$(OBJS)`).
  - The command `$(CC) $(C_FLAGS) $(OBJS) -o $@ $(C_LINK)` uses the compiler (`gcc`) to link the object files (`$(OBJS)`) into an executable (`$@`, which will be `main`). The `-lm` flag is added for linking the math library.

```makefile
$(BUILD_DIR)/%.c.o: %.c
	@mkdir -p $(dir $@)
	$(CC) $(C_FLAGS) -c $< -o $@
```
- This rule **compiles `.c` files into `.o` object files**.
  - It applies to **any `.c` file.**
  - `@mkdir -p $(dir $@)`: This creates the necessary directories inside `$(BUILD_DIR)` to hold the object file. The `-p` flag ensures that any missing directories are created.
  - `$(CC) $(C_FLAGS) -c $< -o $@`: This invokes the compiler (`gcc`) with the flags in `$(C_FLAGS)` to compile the `.c` file (`$<`) into the corresponding `.o` object file (`$@`).

#### **5. Clean Target**
```makefile
.PHONY: clean
clean:
	@rm -f $(TARGET_EXEC)
	@rm -rf $(BUILD_DIR)
```
- `.PHONY: clean`: This marks `clean` as a "phony" target, meaning it doesn’t correspond to a file but is a command to run.
- `clean`: This target removes the built executable (`$(TARGET_EXEC)`, i.e., `main`) and the entire `build` directory (`$(BUILD_DIR)`), cleaning up all object files and the executable.

#### **Summary of the Workflow**

1. **Compile Source Files**: The `$(TARGET_EXEC)` target depends on the object files (`$(OBJS)`), which are built from source files found in the `src` directory.
2. **Create Directories for Object Files**: For each source file, the object file is placed in the `build` directory, creating the necessary subdirectories.
3. **Link the Object Files**: Once the object files are compiled, they are linked together into an executable (`main`) using `gcc` with the specified flags.
4. **Clean the Build**: The `clean` target can be invoked to remove the executable and all object files, essentially resetting the build environment.

#### **Important Commands**

- **`make`**: Will build the `main` executable.
- **`make clean`**: Will clean the build directory and remove the executable.

**Note**: If the `CROSS_COMPILE` variable is set (uncommented), it can be used for cross-compiling (e.g., to build for ARM instead of x86).

### how to use the generated excutable

Once the `make` command has successfully compiled the code into an executable (e.g., `main`), you need to transfer and run the executable on the **Zynq processor** through the **PetaLinux** environment. Below are the detailed steps for how the generated executable is used on a Zynq processor with PetaLinux:

#### **Steps to Run the Executable on Zynq Processor with PetaLinux**

1, **Set Up PetaLinux on Your Host Machine**:
Before running the executable on the Zynq processor, you need to **set up PetaLinux** and ensure that you have **an appropriate cross-compilation environment**. PetaLinux is an embedded Linux development environment provided by Xilinx to **build custom Linux-based applications** for Zynq and other FPGA platforms.

- **Ensure that PetaLinux is installed and properly configured on your host machine**. If you haven't installed it yet, refer to the [Xilinx PetaLinux documentation](https://www.xilinx.com/support/documentation-navigation/embedded-design-tools.html).

2, **Create and Configure PetaLinux Project**:
- If not done already, you must **create a PetaLinux project** to configure the system for the Zynq processor.
- You can use the PetaLinux tools to create the project based on the specific hardware platform you are working with (e.g., ZCU102, ZedBoard, etc.).

Example command to create a PetaLinux project:

```bash
petalinux-create -t project --name my_project
cd my_project
petalinux-config
```

**The `petalinux-config` command allows you to configure the kernel, device tree, and other settings**.

3, **Build the Linux System for Zynq**:
Once the PetaLinux project is created, you can build the complete Linux system for your Zynq FPGA board, which includes the kernel, root filesystem, bootloader (e.g., U-Boot), and device tree.

Example command to build the system:

```bash
petalinux-build
```

This will produce the necessary files for running Linux on your Zynq processor, such as:
- `images/linux/boot.bin` (Bootloader)
- `images/linux/uImage` (Kernel Image)
- `images/linux/devicetree.dtb` (Device Tree Blob)
- `images/linux/rootfs.tar.gz` (Root Filesystem)

4, **Prepare the Zynq FPGA for Running Linux**:
Before you can run the executable on the Zynq processor, you need to load the Linux system onto the FPGA. This usually involves:
- **Flashing the bootloader and kernel** to the Zynq device's SD card or another storage device.
- **Connecting the FPGA board** to your host machine, typically over **a serial or SSH connection**.

For example, you can **use `boot.bin` (bootloader and FPGA bitstream) to flash the SD card** for booting the system on the Zynq processor.

5, **Transfer the Executable to the Zynq Device**:
After building the software, you need to transfer the compiled executable (e.g., `main`) to the **Linux environment** running on the Zynq processor. You can use **`scp` (secure copy)** or other file transfer methods to **move the executable to the Zynq device's filesystem**.

Example using `scp`:

```bash
scp main root@<zynq-ip>:/home/root/

scp main root@127.0.0.1:/home/root/
```

Replace `<zynq-ip>` with the actual IP address of your Zynq board. This will copy the `main` executable to the home directory of the root user.

6, **Connect to the Zynq Processor**:
Once Linux is running on the Zynq processor and the executable is transferred, you need to connect to the device. You can do this via **SSH** or through a **serial terminal**.

Example using SSH:

```bash
ssh root@<zynq-ip>
```

This will open a terminal session on the Zynq processor.

7, **Run the Executable on Zynq**:
After logging in to the Zynq device, navigate to the directory where the executable was transferred and run it.

Example:

```bash
cd /home/root/
./main
```

**This will execute the `main` program on the Zynq processor**, and you should see it working **with the hardware** (e.g., **NoC emulation or other functionality specified in the software**).

8, **Check Output (if needed)**:
- If the program generates output to the console (e.g., via `printf` or logging), you will see it directly in the terminal.
- If the program generates a CSV file or other output files, you can transfer them back to your host machine for analysis using `scp` or similar methods.

#### **Summary of Steps:**
1. **Prepare PetaLinux**: Set up a PetaLinux project for your specific Zynq platform.
2. **Build the Linux System**: Build the kernel, bootloader, and filesystem using PetaLinux.
3. **Transfer the Executable**: Copy the compiled executable (e.g., `main`) to the Zynq device.
4. **Run the Executable**: Log in to the Zynq device via SSH and run the executable.

#### **Things to Note**:
- **Cross-compilation**: If you are cross-compiling, ensure that the `Makefile` is set up to use the proper cross-compiler toolchain to build executables for the ARM architecture of the Zynq processor.
- **File Transfer**: Depending on the Zynq system configuration, file transfer can happen over a USB storage device, FTP, or SSH.
- **Executable Compatibility**: Ensure that the executable is compiled for the correct architecture (ARM for Zynq) and is compatible with the version of Linux running on the Zynq processor.

By following these steps, you should be able to run the compiled **EmuNoC** executable on your **Zynq processor** using **PetaLinux**.

